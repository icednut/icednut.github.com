{"data":{"site":{"siteMetadata":{"title":"Icednut's Notes","author":"Will Lee","siteUrl":"https://icednut.github.io"}},"markdownRemark":{"id":"621aa2b6-8874-57f8-9bc0-8f45205a575b","excerpt":"들어가기 전에최근에 Deadlock이 뭔지 고민해보는 시간이 있었다. 뭐 요즘 들어서 Reactor다 Akka다 뭐다 해서 비동기 프로그래밍을 손쉽게 할 수 있는 프레임워크나 라이브러리가 있어서 Deadlock에 대해 신경을 안쓰고 살고 있어 대답이 선뜻 나오질 못했다. Deadlock…","html":"<h2>들어가기 전에</h2>\n<p>최근에 Deadlock이 뭔지 고민해보는 시간이 있었다. 뭐 요즘 들어서 Reactor다 Akka다 뭐다 해서 비동기 프로그래밍을 손쉽게 할 수 있는 프레임워크나 라이브러리가 있어서 Deadlock에 대해 신경을 안쓰고 살고 있어 대답이 선뜻 나오질 못했다. Deadlock이 뭔가요에 대한 질문에 그냥 막연히 다수의 Thread가 서로의 Lock을 기다리는 상황이라고만 대답했는데, 이참에 좀 더 구체적으로 Deadlock이 뭐고 원인, 해결에는 뭐가 있는지 알아봐야 겠다. 정리 하는김에 Java Fork &#x26; Join, ThreadLocal, stream parallel에 대해서도 살펴봐야겠다.  </p>\n<h2>Deadlock의 원인</h2>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f8c55477d6ad3e3adaf9ef703a60edd3/48a11/deadlock.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 500px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 80%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAY2RNJTAf//EABgQAAMBAQAAAAAAAAAAAAAAAAECAwAS/9oACAEBAAEFAoKjIypqjmkq8Y2GY9N//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAgMBAAAAAAAAAAAAAAAAAAECEBEh/9oACAEBAAY/AuxRiihq9P/EABoQAAIDAQEAAAAAAAAAAAAAAAERABAhcUH/2gAIAQEAAT8hGHDye8+QYAJVTBuqsf/aAAwDAQACAAMAAAAQUw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAEBAAIBBQAAAAAAAAAAAAABEQAhQTFxgcHw/9oACAEBAAE/EGAHRWr3yCfepDPeTbAa8YdCcavRcLUcH0y87sDbXP/Z'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"현실에서 Deadlock 상황\"\n        title=\"\"\n        src=\"/static/f8c55477d6ad3e3adaf9ef703a60edd3/48a11/deadlock.jpg\"\n        srcset=\"/static/f8c55477d6ad3e3adaf9ef703a60edd3/8ee9c/deadlock.jpg 148w,\n/static/f8c55477d6ad3e3adaf9ef703a60edd3/ebbe7/deadlock.jpg 295w,\n/static/f8c55477d6ad3e3adaf9ef703a60edd3/48a11/deadlock.jpg 500w\"\n        sizes=\"(max-width: 500px) 100vw, 500px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<blockquote>\n<p>데드락은 예전부터 <code class=\"language-text\">식사하는 철학자 dining philosophers</code> 문제로 널리 알려져 왔다. 다섯 명의 철학자가 중국 음식점에 저녁 식사를 하러 가서 둥그런 테이블에 앉았다. 테이블에는 다섯 개의 젓가락(다섯 쌍이 아닌 다섯 개)이 개인별 접시 사이에 하나씩 놓여있다. 철학자는 ‘먹는’ 동작과 ‘생각하는’ 동작을 차례대로 반복한다. 먹는 동안에는 접시 양쪽에 있는 젓가락 두 개를 모아 한 쌍을 만들어야 자신의 접시에 놓인 음식을 먹을 수 있고, 음식을 먹은 이후에는 젓가락을 다시 양쪽에 하나씩 내려 놓고 생각을 시작한다.  </p>\n<p>(중략)</p>\n<p>모든 철학자가 각자 자기 왼쪽에 있는 젓가락을 집은 다음 오른쪽 젓가락을 사용할 수 있을 때까지 기다렸다가 오른쪽 젓가락을 집어서 식사를 한다면, 모든 철학자가 더 이상 먹지 못하는 상황에 다다를 수 있다. 철학자 모두가 먹지 못하는 상황은 음식을 먹는 데 필요한 자원을 모두 다른 곳에서 확보하고 놓지 않기 때문에 모두가 서로 상대방이 자원을 놓기만을 기다리는, 이른바 <code class=\"language-text\">데드락</code>이 걸린다.<br>\n<code class=\"language-text\">자바 병렬 프로그래밍 P.305</code></p>\n</blockquote>\n<p>식사하는 철학자의 문제를 Java Thread에 접목하여 Deadlock이 생기는 과정을 살펴보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token comment\">// 데드락 위험이 있는 코드</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LeftRightDeadlock</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> left <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> right <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">leftRight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">rightLeft</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">doSomethingElse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>스레드 A가 락 left을 확보한 상태에서 락 right을 확보하려 대기</li>\n<li>스레드 B가 락 right을 확보한 상태에서 락 left을 확보하려고 대기</li>\n<li>양쪽 스레드 A, B는 서로가 락을 풀기를 영원히 기다리게 됨</li>\n</ul>\n<p>위와 같이 Java Thread에서도 스레드 하나가 특정 락(Lock)을 놓지 않고 계속 잡고 있으면 그 락을 확보하려는 다른 스레드는 락이 풀릴 때까지 기다리는 수 밖에 없다. Deadlock은 Thread가 두 개의 락을 획득하려 하는 코드에서 나타난다. 학교에서 배울 때는 이 정도 수준에서 멈추는 경우가 많은데 데드락은 상용 서비스를 시작하고 나서 시스템에 부하가 걸리는 경우와 같이 최악의 상황에서 그 모습을 드러내곤 한다. 더군다나 아주 심도있는 방법으로 부하 테스트(load-testing)을 진행했다 하더라도 발생 가능한 데드락 모두 찾아낼 수는 없다. JVM에서는 데이터베이스 서버와 같이 데드락 상태 추적 기능이 없기 때문에 Java Application에서 데드락이 발생했을 때 정상으로 되돌리려 한다면 애플리케이션을 종료하고 다시 실행하는 것밖에 없다.</p>\n<h2>Deadlock 예방하기</h2>\n<h3>방법 1. Lock이 발생하는 순서를 정해놓는다.</h3>\n<blockquote>\n<p>프로그램 내부의 모든 스레드에서 필요한 락을 모두 같은 순서로만 사용한다면, 락 순서에 의한 데드락은 발생하지 않는다.<br>\n<code class=\"language-text\">자바 병렬 프로그래밍 P.307</code></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 해결 전: 데드락 위험이 있는 코드\npublic void transferMoney (Account fromAccount, Account toAccount, DollarAmount amount) {\n  synchronized (fromAccount) {\n    synchronized (toAccount) {\n      if (fromAccount.getBalance().compareTo(amount) &lt; 0) {\n        throw new InsufficientFundsException();\n      } else {\n        fromAccount.debit(amount);\n        toAccount.credit(amount);\n      }\n    }\n  }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>위 코드를 얼핏보면 경합이 일어나지 않을 코드 같다. 하지만 파라미터 fromAccount와 toAccount에 순서만 달리해서 동시 호출이 일어난다면 데드락이 걸릴 확률이 증가하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// 해결 후: Lock이 발생하는 순서를 제어한 경우\nprivate static final Object tieLock = new Object();\n\npublic void transferMoney(final Account fromAccount, final Account toAccount, final DollarAmount amount) {\n\n  class Helper {\n    public void transfer() {\n      if (fromAccount.getBalance().compareTo(acmount) &lt; 0) {\n        throw new InsufficientFuncsException();\n      } else {\n        fromAccount.debit(amount);\n        toAccount.credit(ammount);\n      }\n    }\n\n  }\n\n  int fromHash = System.identityHashCode(fromAccount);\n  int toHash = System.identityHashCode(toAccount);\n\n  if (fromHash &lt; toHash) {\n    synchronized(fromAccount) {\n      synchronized(toAccount) {\n        new Helper().transfer();\n      }\n    }\n  } else if (fromHash &gt; toHash) {\n    synchronized(toAccount) {\n      synchronized(fromAccount) {\n        new Helper().transfer();\n      }\n    }\n  } else {\n    synchronized (tieLock) {\n      synchronized(fromAccount) {\n        synchronized(toAccount) {\n          new Helper().transfer();\n        }\n      }\n    }\n  }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>방법 2. 오픈 호출</h3>\n<p>메소드 호출이라는 것은 그 너머에 어떤 일이 일어나는지 모르게 막아주는 추상화 방법이다. 하지만 호출한 메소드 내부에서 어떤 일이 일어나는지 알지 못하기 때문에 특정 락을 확보한 상태에서 다른 메소드를 호출한다는 것은 파급 효과를 분석하기가 어렵고 위험한 일이다. 이에 따라 락을 전혀 확보하지 않은 상태에서 메소드를 호출하는 것이 좋은데 이것을 오픈 호출이라고 한다. (스레드 안정성을 확보하기 위해 캡슐화 기법encapsulation을 사용하는 것과 비슷)  </p>\n<p>락을 확보하지 않은 상태에서 메소드를 호출하는게 관건!  </p>\n<h3>방법 3. 락의 시간 제한</h3>\n<p>암묵적인 락 synchronized 말고 락 시간을 제한할 있는 Lock 클래스의 tryLock 메소드를 사용한다. 암묵적인 락은 락을 확보할 때까지 영원히 기다리지만, Lock 클래스 등의 명시적인 락은 일정 시간을 정해두고 그 시간 동안 락을 확보하지 못한다면 tryLock 메소드가 오류를 발생시키도록 할 수 있다.</p>\n<h2>스레드 덤프를 활용한 Deadlock 분석하기</h2>\n<p>스레드 덤프 분석이라면 여기 훌륭한 글이 이미 있다.\n<a href=\"http://d2.naver.com/helloworld/10963\">http://d2.naver.com/helloworld/10963</a></p>","frontmatter":{"title":"Deadlock이 뭐지? (Java Thread와 Deadlock에 대한 고찰)","date":"2016-08-06 00:00:00","tags":["java","Thread","Deadlock"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2016/08/06/20160806-about_deadlock/","previous":{"fields":{"slug":"/2016/08/03/20160803-ddd_reading_memo/"},"frontmatter":{"title":"나만의 책속 한 줄 -  책 'DDD Start!'를 읽으면서..."}},"next":{"fields":{"slug":"/20161201-front_end_themes/"},"frontmatter":{"title":"개인적으로 마음에 드는 웹 테마들"}}}}