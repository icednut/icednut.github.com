{"data":{"site":{"siteMetadata":{"title":"Icednut's Notes","author":"Will Lee","siteUrl":"https://icednut.github.io"}},"markdownRemark":{"id":"54124ba6-414d-574c-8b65-d325aabc081a","excerpt":"출처: 스칼라로 배우는 함수형 프로그래밍 8장Chpater 08. 프로퍼티 기반 테스트이번 챕터에서 다룰 내용ScalaCheck라는 프로퍼티 기반 테스트 라이브러리를 개발해보자.7장에서 배운 결과물을 프로퍼티 기반 테스트해보기.ScalaCheck: https://github.com…","html":"<p>출처: 스칼라로 배우는 함수형 프로그래밍 8장</p>\n<h2>Chpater 08. 프로퍼티 기반 테스트</h2>\n<p>이번 챕터에서 다룰 내용</p>\n<ul>\n<li>ScalaCheck라는 프로퍼티 기반 테스트 라이브러리를 개발해보자.</li>\n<li>7장에서 배운 결과물을 프로퍼티 기반 테스트해보기.</li>\n<li>ScalaCheck: <a href=\"https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md\">https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md</a></li>\n</ul>\n<br/>\n<br/>\n<h3>프로퍼티 기반 테스트(property-based test)가 뭘까?</h3>\n<h4>프로퍼티 기반 테스트와 전통적인 유닛 테스트의 차이</h4>\n<p>만약 타입이 List[Int]인 list1과 list2가 있다고 하자.</p>\n<p>이에 대해 <code class=\"language-text\">list1의 사이즈와 list2 사이즈를 더한 값은 list1, list2 들을 합한 리스트의 사이즈와 같다</code> 라는 테스트 문제를 코딩한다고 하면 어떻게 하겠는가?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">- 임의의 list1과 list2를 만든다.\n- list1.size + list2.size == (list1 ::: list2).size 라고 코딩하고 돌려본다.\n- 성공한다.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>위와 같이 테스트 유닛을 개발할 것이다. 하지만 만약 <code class=\"language-text\">list1.size + list2.size == (list1 ::: list2).size</code> 라는 predicate 구문을 만족하지 않는 데이터셋이 존재한다고 가정했을 때 이를 어떻게 증명할 것인가? 아마도 list1, list2라는 임의의 리스트를 만드는 것을 또 코딩해야 할텐데 좀 번거롭지 않은가? 난 단지 predicate 구문만 맞는지 증명하고 싶을 뿐인데…</p>\n<p><u>프로퍼티 기반 검사를 적용하면 임의의 테스트 데이터를 생성하는 부분은 누군가에게 위임하고 개발자는 predicate 구문에만 집중하면 된다.</u> </p>\n<p>프로퍼티 기반 테스트란 뭔지 정리하자면, </p>\n<ul>\n<li>특정 메소드나 클래스에 대해 자동으로 테스트 기반 데이터를 랜덤으로 생성하고, 그 데이터로 테스트하는 테스트 기법을 말한다.</li>\n<li>책에서는 프로그램 행동 방식의 서술(Predicate)과 그런 행동 방식을 검사하는 Test Case의 생성을 분리하는 테스트 기법이라고 설명한다.</li>\n</ul>\n<p>스칼라에서 property-based testing의 구현체로는 ScalaCheck가 있으며 이 라이브러리를 사용하면 프로퍼티 기반의 테스트를 손쉽게 진행할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>scalacheck</span><span class=\"token punctuation\">.</span>Prop<span class=\"token punctuation\">.</span>forAll\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>scalacheck</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">{</span>Gen<span class=\"token punctuation\">,</span> Properties<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">object</span> ScalaCheckExercise <span class=\"token keyword\">extends</span> Properties<span class=\"token punctuation\">(</span><span class=\"token string\">\"ScalaCheck Exercise\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">val</span> intList <span class=\"token operator\">=</span> Gen<span class=\"token punctuation\">.</span>listOf<span class=\"token punctuation\">(</span>Gen<span class=\"token punctuation\">.</span>choose<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">val</span> prop <span class=\"token operator\">=</span> forAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>reverse <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> forAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>headOption <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>lastOption<span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">val</span> failingProp <span class=\"token operator\">=</span> forAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>reverse <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">)</span>\n\n  prop<span class=\"token punctuation\">.</span>check\n  failingProp<span class=\"token punctuation\">.</span>check\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>첫 느낌은 Java의 Cucumber와 비슷하지만 뭔가 더 세부적이고 테스트 데이터셋을 무작위로 생성(<code class=\"language-text\">Gen.list</code>, <code class=\"language-text\">Gen.choose</code>)하는 것이 닮은듯 닮지 않았다.</p>\n<h4>프로퍼티 기반 테스트의 특징</h4>\n<ul>\n<li>property-based testing에서 property는 테스트 데이터셋과 테스트할 predicate 구문을 통해 만든 테스트 대상을 말한다. </li>\n<li>ex: <code class=\"language-text\">forAll(intList)(ns =&gt; ns.reverse.reverse == ns)</code></li>\n<li>\n<p><code class=\"language-text\">forAll</code>이라는 커링을 실행하면 <code class=\"language-text\">property 인스턴스</code>를 반환한다.</p>\n<ul>\n<li>정확하진 않지만 일단 위의 코드를 바탕으로 <code class=\"language-text\">property</code> 객체라고 추측하자.</li>\n</ul>\n</li>\n<li>이 <code class=\"language-text\">property</code> 인스턴스에는 <code class=\"language-text\">check</code>라는 메소드를 갖고 있다.</li>\n<li><code class=\"language-text\">check</code> 메소드가 호출되면 테스트 데이터 생성기(<code class=\"language-text\">Gen</code>)에서 랜덤으로 생성한 데이터셋(<code class=\"language-text\">intList</code>)을 바탕으로 predicate 람다를 실행하여 그것이 모두 참인지를 판단한다.</li>\n<li>만약 거짓이 발생하면 바로 테스트 종료하고 결과를 출력한다.</li>\n</ul>\n<p>위 특징을 염두하여 예제코드를 실행하면 다음과 같은 결과가 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token comment\">// prop.check</span>\n<span class=\"token operator\">+</span> OK<span class=\"token punctuation\">,</span> passed <span class=\"token number\">100</span> tests<span class=\"token punctuation\">.</span>\n\n<span class=\"token comment\">// failingProp.check</span>\n<span class=\"token operator\">!</span> Falsified after <span class=\"token number\">5</span> passed tests<span class=\"token punctuation\">.</span>\n<span class=\"token operator\">></span> ARG_0<span class=\"token operator\">:</span> List<span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">></span> ARG_0_ORIGINAL<span class=\"token operator\">:</span> List<span class=\"token punctuation\">(</span><span class=\"token string\">\"93\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"12\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"4\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"70\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>앞에서 개발한 비동기 합산 함수인 <code class=\"language-text\">sum: List[Int]</code>에 프로퍼티 기반 테스트를 적용하면 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token comment\">// 목록을 뒤집어서 합해도 결과는 같아야 한다.</span>\n<span class=\"token keyword\">val</span> intList1 <span class=\"token operator\">=</span> Gen<span class=\"token punctuation\">.</span>listOf<span class=\"token punctuation\">(</span>Gen<span class=\"token punctuation\">.</span>choose<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> prop1 <span class=\"token operator\">=</span> forAll<span class=\"token punctuation\">(</span>intList1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> sum<span class=\"token punctuation\">(</span>ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> sum<span class=\"token punctuation\">(</span>ns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 목록의 모든 요소가 같아도 원하는 합산 결과가 나와야 한다.</span>\n<span class=\"token keyword\">val</span> intList2 <span class=\"token operator\">=</span> Gen<span class=\"token punctuation\">.</span>listOf<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> prop2 <span class=\"token operator\">=</span> forAll<span class=\"token punctuation\">(</span>intList2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> sum<span class=\"token punctuation\">(</span>ns<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>이번 챕터에서는 ScalaCheck을 직접 개발해보자.</p>\n<ul>\n<li>ScalaCheck을 쓰는 방법을 알아가는게 아니라 실제로 ScalaCheck을 개발한다.</li>\n<li>처음부터 개발하라고 하면 막막하니깐 위에 적은 <code class=\"language-text\">ScalaCheckExercise</code> 라는 실행 코드 예제를 기반으로 ScalaCheck을 개발하자.</li>\n</ul>\n<h3>ScalaCheck 개발 시작!</h3>\n<p>앞의 예제코드를 하나하나씩 뜯어서 살펴보면서 영감을 얻도록 하자!</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> intList <span class=\"token operator\">=</span> Gen<span class=\"token punctuation\">.</span>listOf<span class=\"token punctuation\">(</span>Gen<span class=\"token punctuation\">.</span>choose<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> prop <span class=\"token operator\">=</span> \n\tforAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>reverse <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> \n\tforAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>headOption <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>lastOption<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h4>Gen 시그니처 작성</h4>\n<p>첫 번째 줄을 가만히 살펴보면 <code class=\"language-text\">Gen.listOf()</code> 와 <code class=\"language-text\">Gen.choose()</code>는 뭔가를 반환하고 있다는 것을 짐작할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> intList <span class=\"token operator\">=</span> Gen<span class=\"token punctuation\">.</span>listOf<span class=\"token punctuation\">(</span>Gen<span class=\"token punctuation\">.</span>choose<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>추측컨데 세 번째 줄에서 forAll 함수 호출부분을 보면 <code class=\"language-text\">Gen.listOf</code>로 만든 리스트를 가지고 predicate를 평가하고 있는 것을 보면 아마도 <code class=\"language-text\">Gen.listOf</code>의 결과물은 테스트 데이터(여기서는 List[Int])를 생성하는 생성기 인스턴스임을 짐작할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> listOf<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>그런데 <code class=\"language-text\">listOf</code>의 파라미터로 <code class=\"language-text\">Gen.choose(0, 100)</code>의 결과를 전달하는 것으로 보아 <code class=\"language-text\">Gen.choose(0, 100)</code>도 뭔가 데이터 생성기를 반환한다고 짐작할 수 있다. 아마도 <code class=\"language-text\">Gen[List[Int]]이라는 리스트</code>를 생성하기 위해서 <code class=\"language-text\">List[Int]</code> 리스트에 들어갈 데이터를 임의로 생성하기 위한 시드 데이터 생성기를 반환하지 않을까 짐작해본다. </p>\n<p>고로 <code class=\"language-text\">Gen.choose()</code>가 반환하는 데이터 생성기는 Gen[Int]가 아닐까?</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> listOf<span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// 일반화하면</span>\n<span class=\"token keyword\">def</span> listOf<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p><strong>잠깐 생각해볼 문제</strong></p>\n<ul>\n<li>위의 테스트 데이터 생성기 함수 <code class=\"language-text\">listOf</code>는 리스트의 크기를 정하지는 않았다. 왜 그럴까?</li>\n<li>만약 리스트의 크기를 정하게 된다면 그 크기만큼의 리스트로 predicate를 평가하게 될텐데 문제 되진 않을까?</li>\n<li>책에서는 <code class=\"language-text\">Gen[List[A]]</code>의 크기를 정하게 된다면 유연한 테스트 검사가 될 수 없다고 한다. 왜 그럴까? (p.162)</li>\n</ul>\n</blockquote>\n<h4>forAll 시그니처 작성</h4>\n<p>그 다음으로 넘어가서 forAll 함수 사용 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> prop <span class=\"token operator\">=</span> \n\tforAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>reverse <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> \n\tforAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>headOption <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>lastOption<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>forAll 함수가 <code class=\"language-text\">Gen[List[Int]]</code>를 받아서 함수를 반환했는데 이 함수에는 predicate를 평가하는 함수이다. 추측한 내용을 바탕으로 forAll 시그니처를 작성하면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> forAll<span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">=></span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Prop\n\n<span class=\"token comment\">// 일반화하면</span>\n<span class=\"token keyword\">def</span> forAll<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> A <span class=\"token keyword\">=></span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Prop</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<h4>Property 시그니처 작성</h4>\n<p>위의 forAll 함수의 반환 결과물을 보면 뭔가 인스턴스를 반환하고 있는 것을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> prop <span class=\"token operator\">=</span> \n\tforAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>reverse <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> \n\tforAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>headOption <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>lastOption<span class=\"token punctuation\">)</span>\n\nprop<span class=\"token punctuation\">.</span>check\n\n<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n<span class=\"token comment\">// prop.check의 테스트 결과 출력</span>\n<span class=\"token operator\">+</span> OK<span class=\"token punctuation\">,</span> passed <span class=\"token number\">100</span> tests<span class=\"token punctuation\">.</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>그런데 <code class=\"language-text\">&amp;&amp;</code>라는 함수와 <code class=\"language-text\">check</code>라는 함수를 호출하는 것으로 보아 prop 인스턴스의 클래스는 <code class=\"language-text\">&amp;&amp;</code>와 <code class=\"language-text\">check</code> 함수를 멤버로 갖고 있을 것 같다. 일단 클래스 보다는 나중에 확장성을 위해서 trait으로 선언하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> Prop <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> <span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> Prop<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Prop <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n    <span class=\"token keyword\">def</span> check<span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여지껏 해왔던 방식대로 제일 나중에 실행하는 함수부터 작성해보자. 이렇게 하는 이유는</p>\n<ul>\n<li>그 함수를 작성하려고 했을 때 어떻게 구현해야 할지를 고민하면서 뭐가 필요한지를 고민하게 된다.</li>\n<li>말이 쉽지 처음엔 엄청 막막할 것이다. 막막함을 없애기 위해 생각하는 힘을 길러야 할 것 같다.</li>\n</ul>\n<h4>Prop의 멤버 함수 구현 고민해보기</h4>\n<h5>Prop.check</h5>\n<p><code class=\"language-text\">prop.check</code>을 호출하면 콘솔에 테스트 결과를 출력하고 있다. 이것은 부수효과이다. 일단 부수효과가 있다는 것을 염두해두자.</p>\n<h5>Prop.&#x26;&#x26;</h5>\n<p><code class=\"language-text\">&amp;&amp;</code> 함수는 또다른 prop을 합성하여 새로운 합성 결과물 Prop을 내놓는 함수이다. 그 근거는 아래 함수 실행코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> prop1 <span class=\"token operator\">=</span> forAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>reverse <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> prop2 <span class=\"token operator\">=</span> forAll<span class=\"token punctuation\">(</span>intList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ns <span class=\"token keyword\">=></span> ns<span class=\"token punctuation\">.</span>headOption <span class=\"token operator\">==</span> ns<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">.</span>lastOption<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> prop <span class=\"token operator\">=</span> prop1 <span class=\"token operator\">&amp;&amp;</span> prop2\n\nprop<span class=\"token punctuation\">.</span>check</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>forAll이 내놓은 prop을 <code class=\"language-text\">&amp;&amp;</code>로 합성하면 prop들, 즉 합성한 prop이 모두 참인지를 check 함수를 호출하면 검사하게 될 것이다.</p>\n<p>사실 여기서 갈림길이 나오는데 책과 내 생각은 이렇다.</p>\n<ul>\n<li>책: 다시 <code class=\"language-text\">Prop.check</code> 구현 생각해보기</li>\n<li>나: <code class=\"language-text\">forAll</code> 구현 생각해보기</li>\n</ul>\n<p>내 생각엔 forAll 구현을 생각해봄으로써 <code class=\"language-text\">&amp;&amp;</code>의 구현을 이끌어내고 더 나아가 <code class=\"language-text\">check</code>까지 진행할 수 있지 않을까? 하는 기대가 있다. (하지만 여기서는 책을 따라가자 ㅜㅜ)</p>\n<h5>다시 Prop.check으로</h5>\n<p><strong>Q1</strong>: 만약 <code class=\"language-text\">prop.check</code> 호출 시  <code class=\"language-text\">&amp;&amp;</code>로 합성한 모든 prop들( <code class=\"language-text\">prop1</code>, <code class=\"language-text\">prop2</code>)을 따로따로 테스트 실행한다면?</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\">prop<span class=\"token punctuation\">.</span>check\n<span class=\"token punctuation\">(</span>prop1 <span class=\"token operator\">&amp;&amp;</span> prop2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>check\nprop1<span class=\"token punctuation\">.</span>check <span class=\"token operator\">&amp;&amp;</span> prop2<span class=\"token punctuation\">.</span>check</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>\n<p>잠깐!! 우선 위와 같은 질문을 하기 전에 전제조건이 있다. <code class=\"language-text\">Prop.&amp;&amp;</code>은 check 함수의 조합이라는 전제조건이 있어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> Prop <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> check<span class=\"token operator\">:</span> <span class=\"token builtin\">Boolean</span>\n  <span class=\"token keyword\">def</span> <span class=\"token operator\">&amp;&amp;</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> Prop<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Prop <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>check <span class=\"token operator\">&amp;&amp;</span> p<span class=\"token punctuation\">.</span>check\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n</li>\n<li>\n<p><strong>A</strong>: check 함수는 부수효과가 있기 때문에 합성할 수 없다. (그리고 부수효과 때문에 결과물을 리턴하지도 않았다.)</p>\n</li>\n<li>\n<p><strong>A</strong>: 그리고 prop1.check과 prop2.check 테스트 결과를 따로따로 실행하면 &#x26;&#x26;를 통해 두 결과가 다 통과되었는지도 파악이 안된다.</p>\n</li>\n</ul>\n<p><strong>Q2</strong>: 그럼 <code class=\"language-text\">&amp;&amp;</code>로 합성하면 합성한 <code class=\"language-text\">prop</code>에 대해서만 <code class=\"language-text\">prop.check</code>을 호출하면 되는거 아닌가?</p>\n<ul>\n<li><strong>A</strong>: 고민해봤는데 prop1은 prop1만의 predicate가 있을 것이고 prop2는 prop2만의 predicate가 있을 것이다.</li>\n<li>prop1과 prop2를 합성한다는 것은 이 predicate들도 &#x26;&#x26;로 합성해야 한다는 것을 의미한다.</li>\n<li>고로 우리가 고민해야될 것은 <code class=\"language-text\">&amp;&amp;</code>를 통해 어떻게 합성할 것인지, 그리고 그 합성한 것의 predicate는 어떻게 유연하게 평가(예를 들어 prop을 <code class=\"language-text\">&amp;&amp;</code>로 합성할 때는 predicate도 <code class=\"language-text\">&amp;&amp;</code>로 합성, prop을 <code class=\"language-text\">||</code>로 합성할 때는 predicate도 <code class=\"language-text\">||</code>로 합성)할 것인지를 고민하면 <code class=\"language-text\">prop.check</code>은 check 함수가 부수효과가 있던 말던 합성된 <code class=\"language-text\">prop</code> 하나만 신경쓰면 되지 않을까?</li>\n</ul>\n<blockquote>\n<p><strong>여기서 잠깐!!</strong></p>\n<ul>\n<li>Q1에서 말한 전제조건\u001c만 없으면 <code class=\"language-text\">check</code> 함수는 부수효과가 있는채로 냅두고 <code class=\"language-text\">&amp;&amp;</code>로 합성하는 코드만 잘 작성하면 되는거 아닐까?  </li>\n<li>그런데 책에서는 Q1의 전제조건을 깔고 check 함수의 부수효과를 없애는 방법을 택했다.</li>\n<li>일단 책은 따라가되 전제조건이 없을 때 <code class=\"language-text\">&amp;&amp;</code>의 구현이 어떻게 될지 살펴봐야겠다. 그렇게 되면 책이 택한 방법에 대한 이유가 좀 더 명확해지지 않을까..</li>\n</ul>\n</blockquote>\n<h5>Prop.check에서 부수효과 없애기</h5>\n<p>일단 check 함수의 부수효과를 없애기 위해서 반환값을 추가하자. 이 반환값은 테스트한 결과 몇 건 성공하고 몇 건 실패했는지를 반환하자. 그러기 위해서는 Either를 택해야 할 것이다. 일단 <code class=\"language-text\">left</code>(실패)는 나중에 생각하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> Prop <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> check<span class=\"token operator\">:</span> Either<span class=\"token punctuation\">[</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> SuccessCount<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">object</span> Prop <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span> SuccessCount <span class=\"token operator\">=</span> <span class=\"token builtin\">Int</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>실패는 실패한 이유와 실패하기 전 성공한 테스트 개수를 추가해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">trait</span> Prop <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> check<span class=\"token operator\">:</span> Either<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>FailedCase<span class=\"token punctuation\">,</span> SuccessCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> SuccessCount<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">object</span> Prop <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span> SuccessCount <span class=\"token operator\">=</span> <span class=\"token builtin\">Int</span>\n    <span class=\"token keyword\">type</span> FailedCase <span class=\"token operator\">=</span> <span class=\"token builtin\">String</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h5>다시 Prop.forAll으로</h5>\n<p>check의 반환을 Unit에서 Either로 바꾸긴 했지만 그 구현을 생각하기엔 아직도 막막하다. 이 때 좀 거슬러 올라가서 prop과 이 prop을 생성하는 forAll을 생각해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> forAll<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> A <span class=\"token keyword\">=></span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Prop</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>일단 책의 내용대로 따라가기가 어려우니 내 머릿속에 떠오르는 생각을 적어보자.</p>\n<ul>\n<li><code class=\"language-text\">forAll(a: Gen[A])</code>을 통해 뭔가 임의의 테스트 데이터를 생성하는 로직이 담긴 함수를 반환할 것이다. 이 함수를 <code class=\"language-text\">g</code>라고 하자. (임의의 테스트 데이터 생성을 위해 난수 발생기가 아마 필요할듯 하다.)</li>\n<li><code class=\"language-text\">g(f: A =&gt; Boolean)</code>를 통해 임의로 생성된 데이터를 f 함수에 넘겨서 평가할 수 있는 prop 객체 혹은 함수가 또 반환될 것이다. 이 반환물을 prop이라고 하자.</li>\n<li>prop.check을 호출하면 트리거를 당긴 것과 같이 순차적으로 임의의 테스트 데이터셋 생성 및 predicate 수행, 테스트 결과 반환이 일어날 것이다.</li>\n</ul>\n<p>일단 위에 떠오르는 생각은 나중에 구현해보기로 하고, 시간 관계상 책에 있는 해답을 추가한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> Prop <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> forAll<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>as<span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>f<span class=\"token operator\">:</span> A <span class=\"token keyword\">=></span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Prop <span class=\"token operator\">=</span> Prop <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> rng<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> randomStream<span class=\"token punctuation\">(</span>as<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>rng<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>zip<span class=\"token punctuation\">(</span>Stream<span class=\"token punctuation\">.</span>from<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>take<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> Passed\n                <span class=\"token keyword\">else</span> Falsified<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">case</span> e<span class=\"token operator\">:</span> Exception <span class=\"token keyword\">=></span> Falsified<span class=\"token punctuation\">(</span>buildMsg<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span>find<span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">.</span>isFalsified<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>getOrElse<span class=\"token punctuation\">(</span>Passed<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">def</span> randomStream<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>g<span class=\"token operator\">:</span> Gen<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>rng<span class=\"token operator\">:</span> RNG<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Stream<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> \n    \tStream<span class=\"token punctuation\">.</span>unfold<span class=\"token punctuation\">(</span>rng<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>rng <span class=\"token keyword\">=></span> Some<span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">.</span>sample<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span>rng<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">def</span> buildMsg<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">:</span> A<span class=\"token punctuation\">,</span> e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">String</span> <span class=\"token operator\">=</span>\n    \ts<span class=\"token string\">\"\"\"\n    \ttest case: $s\n    \tgenerated an exception: ${e.getMessage}\n    \tstack trace:\n    \t${e.getStackTrace.mkString(\"\\n\")}\n    \t\"\"\"</span><span class=\"token punctuation\">.</span>stripMargin\n    \n    <span class=\"token keyword\">def</span> check<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Result <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> Result <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> isFalsified<span class=\"token operator\">:</span> <span class=\"token builtin\">Boolean</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">object</span> Passed <span class=\"token keyword\">extends</span> Result <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> isFalsified <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Falsified<span class=\"token punctuation\">(</span>failure<span class=\"token operator\">:</span> FailedCase<span class=\"token punctuation\">,</span> success<span class=\"token operator\">:</span> SuccessCount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">extends</span> Result <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> isFalsified <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> TestCases <span class=\"token operator\">=</span> <span class=\"token builtin\">Int</span>\n<span class=\"token keyword\">type</span> Result <span class=\"token operator\">=</span> Option<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>FailedCase<span class=\"token punctuation\">,</span> SuccessCount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Prop<span class=\"token punctuation\">(</span>run<span class=\"token operator\">:</span> TestCases <span class=\"token keyword\">=></span> Result<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>","frontmatter":{"title":"스칼라 스터디 Day07 - 속성 기반 검사","date":"2019-01-29 19:59:59","tags":["scala","functional programming"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/20190129-scala-and-functional-programming-day07/","previous":{"fields":{"slug":"/20190107-scala-and-functional-programming-day06/"},"frontmatter":{"title":"스칼라 스터디 Day06 - 순수 함수적 병렬성"}},"next":{"fields":{"slug":"/20190131-rxjava-infinite-iterable/"},"frontmatter":{"title":"RxJava를 이용하여 크기를 가늠할 수 없는 Iterable에서 데이터 읽고 처리하기"}}}}