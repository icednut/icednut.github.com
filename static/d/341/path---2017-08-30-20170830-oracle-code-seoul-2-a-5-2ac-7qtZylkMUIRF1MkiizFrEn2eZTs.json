{"data":{"site":{"siteMetadata":{"title":"Icednut's Notes","author":"Will Lee","siteUrl":"https://icednut.github.io"}},"markdownRemark":{"id":"f135ef62-93b3-5d4d-b7ce-539793e80c6e","excerpt":"CQRS를 언제, 왜, 그리고 어떻게 사용할 것인가?CQRS Motivation: 기존 방식의 CRUD Application으로는 상태 정보를 관리하기 힘듬 (따로 구현해야 됨). 상태 정보를 저장할 수 있도록 구현이 필요. DB…","html":"<h3>CQRS를 언제, 왜, 그리고 어떻게 사용할 것인가?</h3>\n<ul>\n<li>CQRS Motivation: 기존 방식의 CRUD Application으로는 상태 정보를 관리하기 힘듬 (따로 구현해야 됨). 상태 정보를 저장할 수 있도록 구현이 필요. DB를 하나만 쓰는 것이 아닌 확장성을 고려한 개발 필요</li>\n<li>Event Sourcing: DB에 현재 상태를 계속 저장. 이에 따라 상태 재생이 가능하게 되고 테스팅이 용이해진다. (Event는 atomic, immutable 해야 된다.)</li>\n<li>\n<p>Event Driven Architecture</p>\n<ul>\n<li>collaboration needed. 주문 시스템을 보면 주문 시 모든 시스템이 Lock이 걸린 뒤 주문을 처리하지 않는다. 각 시스템이 용이하게 운영될 수 있도록 이벤트를 통해 분산 시스템이 될 수 있어야 함. (comminication via events, published reliably)</li>\n<li>split-up transations. 주문이 시작되면 여러 개의 트랜잭션으로 나눠지는데 이 때문에 일관성 확보가 가능해짐(?)</li>\n</ul>\n</li>\n<li>\n<p>Command Query Responsability Segregation</p>\n<ul>\n<li>읽기와 쓰기를 분리.</li>\n<li>command는 이벤트 방식으로 전달.</li>\n<li>읽기와 쓰기를 연결하는 것은 Event Store. Event Store에서의 상태 정보는 IMDG로도 관리할 수 있다. (ex: 커피 주문 시작은 CommandService에서 처리하면 이벤트 스토어로 이벤트를 날린 뒤 QueryService로 이벤트를 전달하여 주문 정보를 저장.)</li>\n<li>분산 시스템이 아닌 단일 시스템에 CQRS를 적용하는 것은 오버헤드를 늘리는 꼴이 될 수도 있다.</li>\n<li>CQRS에서는 읽기 DB와 쓰기 DB 등 서비스 별로 여러 개가 있을 수 있는데 동기화를 할 필요가 없다. (동기화는 좋은 생각이 아님) 오히려 이벤트를 통한 일관성 확보가 중요.</li>\n</ul>\n</li>\n<li>CQRS를 통해 어떤 문제를 해결할 수 있을까? 일반적인 CRUD 방식보다 확장성이 좋다. 또한 읽기서비스에서 failover가 가능해진다.</li>\n<li>\n<p>Demo 시연</p>\n<ul>\n<li>Java EE &#x26; Kafka를 활용한 커피 주문 시스템 구현</li>\n<li><a href=\"https://github.com/sdaschner/scalable-coffee-shop\">https://github.com/sdaschner/scalable-coffee-shop</a></li>\n<li>참고로 Oracld Event Hub에서 카프카를 사용할 수 있다.</li>\n<li>더 자세한 데모 설명은 sebastian-daschner.com을 참조.</li>\n</ul>\n</li>\n</ul>\n<h3>Java 9와 Spring 5로 바라보는 Java의 미래</h3>\n<ul>\n<li>2017/09/21 java 9과 spring 5이 출시될 예정</li>\n<li>Java는 위기를 맞이하면서 발전을 거듭해 왔다.</li>\n<li>\n<p>Java 위기 1</p>\n<ul>\n<li>서블릿, EJB, JSP, 크고 무거운 WAS, 다양한 웹 프레임워크 등 코드가 복잡해짐.</li>\n<li>자바 객체지향의 기본으로 돌아가자는 움직임이 일어남.</li>\n</ul>\n</li>\n<li>\n<p>Java 위기 2</p>\n<ul>\n<li>언어 발전의 요구와 호환성</li>\n<li>언어 발전과 구버전의 하위 호환성 둘 다 잡아야 되는 상황 발생. 다행히 Java는 언어 발전과 함께 하위 호환성도 지킴.</li>\n</ul>\n</li>\n<li>\n<p>Java 위기 3</p>\n<ul>\n<li>간결하고 관례를 통한 개발 움직임이 대두되기 시작. (특히 Ruby)</li>\n<li>Java에서도 Annotation이 등장하면서 관례 적용이 시작됨</li>\n</ul>\n</li>\n<li>\n<p>Java 위기 4</p>\n<ul>\n<li>함수형 프로그래밍과 비동기 논블로킹 개발의 도전 대두</li>\n<li>대용량 비동기 논블로킹 프로그래밍으로는 함수형 프로그래밍이 좋다고 보는 시각이 늘어남.</li>\n</ul>\n</li>\n<li>\n<p>Java 9과 Spring 5</p>\n<ul>\n<li>새로운 위기: 애노테이션, 메타프로그래밍, 관례의 범람</li>\n<li>어노테이션은 코드 행위를 규정하는 것이 아닌 메타 정보를 담는다. 상속, 확장이 없음. 따라서 어노테이션은 테스트가 불가.</li>\n<li>또한 메타 어노테이션에 대한 동작 규정이 없음 (ex: @Controller)</li>\n<li>Relection과 런타임 바이트코드 생성의 문제는 테스트, 디버깅이 힘들고 성능이 저하됨</li>\n<li>이 위기를 어떻게 극복할까? 함수형 스타일의 자바 웹 코드로 전환 (리액티브, 함수의 조함, 불변객체 사용)</li>\n<li>Spring 5에서는 더 이상 서블릿을 안써도 된다. HandlerFunction, RouterFunction을 사용</li>\n</ul>\n</li>\n<li>\n<p>Java 9</p>\n<ul>\n<li>Java 9에는 Flow API와 Reactive Streams가 추가 된다고 한다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Oracle Code Seoul","date":"2017-08-30 09:00:12","tags":["Java"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2017/08/30/20170830-oracle-code-seoul/","previous":{"fields":{"slug":"/2017/07/22/20170722-angular-seminar-note/"},"frontmatter":{"title":"앵귤러 첫걸음 저자 세미나 노트"}},"next":{"fields":{"slug":"/2017/09/02/20170902-spark-sql-with-avro-parquet/"},"frontmatter":{"title":"Spark SQL을 이용하여 avro 파일과 parquet 파일 다루기"}}}}