{"data":{"site":{"siteMetadata":{"title":"Icednut's Notes","author":"Will Lee"}},"markdownRemark":{"id":"1e6f752f-17e7-582f-a3ed-b4be8d004a81","excerpt":"출처: 스칼라로 배우는 함수형 프로그래밍 1장, 2장CHAPTER 01. 함수형 프로그래밍이란 무엇인가?함수형 프로그래밍이란 부수 효과(Side Effect)가 없는 순수 함수(Pure Function…","html":"<p>출처: 스칼라로 배우는 함수형 프로그래밍 1장, 2장</p>\n<h2>CHAPTER 01. 함수형 프로그래밍이란 무엇인가?</h2>\n<p>함수형 프로그래밍이란 부수 효과(Side Effect)가 없는 순수 함수(Pure Function)으로만 프로그램을 구축한다는 것을 의미한다. 그럼 <u>부수효과란 무엇일까? 결과를 돌려주는 것 이외에 어떤 일을 수행하는 함수를 카리켜 <strong>부수효과가 있는 함수</strong></u> 라고 칭한다.</p>\n<ul>\n<li>\n<p>부수효과가 있는 함수 예시</p>\n<ul>\n<li>파라미터 변수를 수정한다.</li>\n<li>자료구조를 제자리에서 수정한다.</li>\n<li>객체의 필드를 설정한다.</li>\n<li>에외(exception)을 던지거나 오류를 내면서 실행을 중단한다.</li>\n<li>콘솔에 출력하거나 사용자의 입력을 읽어들인다.</li>\n<li>파일에 기록하거나 파일에서 읽어들인다.</li>\n<li>화면에 그린다.</li>\n</ul>\n</li>\n</ul>\n<p>이 책은 모든 종류의 프로그램을 부수 효과 없이 표현하는 방법을 설명한다. 부수 효과 없는 함수들로만 프로그램을 개발하면 뭐가 좋을까?</p>\n<ul>\n<li>순수 함수들로만 프로그램을 작성하면 모듈성(modularity)이 증가하게 됨</li>\n<li>모듈성 덕분에 test, 재사용, 병렬화, 일반화, 분석이 쉬워 진다.</li>\n<li>순수 함수는 버그가 생길 여지가 훨씬 적다 (부수 효과가 없기 때문)</li>\n</ul>\n<p>그럼 부수 효과가 있는 간단한 함수 예시를 바탕으로 부수 효과를 제거해가면서 FP의 이점을 살펴보자.</p>\n<h3>Step1. 부수 효과가 있는 프로그램</h3>\n<p>커피숍에서 사용하는 커피구매 프로그램을 구현해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> Cafe <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> buyCoffee<span class=\"token punctuation\">(</span>cc<span class=\"token operator\">:</span> CreditCard<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Coffee <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> cup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Coffee<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    cc<span class=\"token punctuation\">.</span>charge<span class=\"token punctuation\">(</span>cup<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">)</span>\n    cup\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>buyCoffee 메소드는 부수 효과가 있는 메소드다. 왜?</p>\n<ul>\n<li>여기서 buyCoffee 메소드의 목적은 단지 하나. Coffee 객체를 돌려주는 것이다.</li>\n<li>Coffee를 돌려주는 것 말고 그 외의 모든 동작은 부수 효과이다.</li>\n<li>정확히 말하자면<code class=\"language-text\">cc.charge(cup.price)</code>가 부수 효과이다.</li>\n<li>왜? 여기서 청구(charge)는 외부 세계와의 일정한 상호 작용이기 때문이다.</li>\n</ul>\n<p>부수 효과가 있으면 왜 안좋을까?</p>\n<ul>\n<li>테스트 코드를 작성하기 어려워 진다.</li>\n<li><code class=\"language-text\">buyCoffee()</code> 메소드의 테스트 코드를 작성하기 위해 실제로 신용카드 회사와 연결해서 카드 이용 대금을 청구하고 싶지는 않을 것이다.</li>\n<li>그러므로 신용카드 연동 방법에 관한 지식을 CreditCard에 집어넣는 것은 좋지 않다.</li>\n</ul>\n<p>그럼 어떻게 고칠까?</p>\n<h3>Step2. 커피 결제를 Payments로 분리하기</h3>\n<p>커피 대금 지급을 위한 Payments 객체를 <code class=\"language-text\">buyCoffee</code>에 전달하면 코드의 모듈성(Modularity)과 검사성(Testability)을 좀 더 높일 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> Cafe <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> buyCoffee<span class=\"token punctuation\">(</span>cc<span class=\"token operator\">:</span> CreditCard<span class=\"token punctuation\">,</span> p<span class=\"token operator\">:</span> Payments<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Coffee <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> cup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Coffee<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        p<span class=\"token punctuation\">.</span>charge<span class=\"token punctuation\">(</span>cc<span class=\"token punctuation\">,</span> cup<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">)</span>\n        cup\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><code class=\"language-text\">p: Payments</code> 파라미터 부분에 Mock 객체를 전달하여 결제에 대한 행동을 목킹할 수 있게 되었다. (검사성이 조금 높아짐)</p>\n<p>그러나 이상적인 방법은 아니다. 왜?</p>\n<ul>\n<li>Payments를 인터페이스로 만들어야 한다. (Mock 구현을 넘겨주기 위해)</li>\n<li>Payment를 목킹한다고 해도 charge 메소드 동작에 대한 상태 변이가 잘 되었는지 확인하는 코드가 필요</li>\n<li>Mock Framework를 써서 처리할 수 있지만 프레임워크를 사용하지 않고 해결할 수 있는 방법이 있다.</li>\n<li>buyCoffee 메소드는 재사용이 어렵다.</li>\n<li>만약 손님이 커피 열두 잔을 주문한다고 하자.</li>\n<li>buyCoffee 메소드를 루프를 돌아서 12번 호출하면 문제가 발생한다.</li>\n<li>신용카드를 12번 청구되기 때문에 수수료도 12번 지불된다. (수수료에 대해 중복 결제 발생)</li>\n</ul>\n<h3>Step3. 부수 효과가 제거된 buyCoffee</h3>\n<p>위 문제를 해결하기 위해 buyCoffee를 새로 만들어야 한다. <u>함수적 해법은 부수 효과(creditCard.charge 혹은 payment.charge)를 제거하고 buyCoffee가 Coffee 뿐만 아니라 청구건을 하나의 값으로 돌려주는 것</u>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> Cafe <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> buyCoffee<span class=\"token punctuation\">(</span>cc<span class=\"token operator\">:</span> CreditCard<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Coffee<span class=\"token punctuation\">,</span> Charge<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> cup <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Coffee<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span>cup<span class=\"token punctuation\">,</span> Charge<span class=\"token punctuation\">(</span>cc<span class=\"token punctuation\">,</span> cup<span class=\"token punctuation\">.</span>price<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>무슨 차이일까?</p>\n<ul>\n<li>청구건의 생성 문제(creditCard.charge 혹은 payment.charge)가 청구건의 처리 또는 연동 문제와 분리 되었다. (charge  메소드를 직접 호출하지 않아도 되기 때문에 연동을 신경쓰지 않아도 됨)</li>\n<li>Charge에 결제 정보를 담아서 반환하기 때문에 여러 잔의 커피 구매에도 결제 정보 변경이 쉬워졌다. 어떻게 그럴까?</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Charge<span class=\"token punctuation\">(</span>cc<span class=\"token operator\">:</span> CreditCard<span class=\"token punctuation\">,</span> amount<span class=\"token operator\">:</span> <span class=\"token builtin\">Double</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> combine<span class=\"token punctuation\">(</span>other<span class=\"token operator\">:</span> Charge<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Charge <span class=\"token operator\">=</span> \n    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cc <span class=\"token operator\">==</span> other<span class=\"token punctuation\">.</span>cc<span class=\"token punctuation\">)</span>\n    \t\tCharge<span class=\"token punctuation\">(</span>cc<span class=\"token punctuation\">,</span> amount <span class=\"token operator\">+</span> other<span class=\"token punctuation\">.</span>amount<span class=\"token punctuation\">)</span>\n    \t<span class=\"token keyword\">else</span>\n    \t\t<span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> Exception<span class=\"token punctuation\">(</span><span class=\"token string\">\"다른 종류의 카드끼리는 결제 정보를 결합할 수 없습니다.\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>커피를 n잔 구매는 어떻게 할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">class</span> Cafe <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> buyCoffee<span class=\"token punctuation\">(</span>cc<span class=\"token operator\">:</span> CreditCard<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>Coffee<span class=\"token punctuation\">,</span> Charge<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* 이전과 같음 */</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">def</span> buyCoffees<span class=\"token punctuation\">(</span>cc<span class=\"token operator\">:</span> CreditCard<span class=\"token punctuation\">,</span> n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>List<span class=\"token punctuation\">[</span>Coffee<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> Charge<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> purchases<span class=\"token operator\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>Coffee<span class=\"token punctuation\">,</span> Charge<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> List<span class=\"token punctuation\">.</span>fill<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>buyCoffee<span class=\"token punctuation\">(</span>cc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// List.fill(n)(x)는 x의 복사본 n개로 이루어진 List를 생성한다.</span>\n        <span class=\"token keyword\">val</span> <span class=\"token punctuation\">(</span>coffees<span class=\"token punctuation\">,</span> charges<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> purchases<span class=\"token punctuation\">.</span>unzip\n        <span class=\"token punctuation\">(</span>coffees<span class=\"token punctuation\">,</span> charges<span class=\"token punctuation\">.</span>reduce<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>c1<span class=\"token punctuation\">,</span> c2<span class=\"token punctuation\">)</span> <span class=\"token keyword\">=></span> c1<span class=\"token punctuation\">.</span>combine<span class=\"token punctuation\">(</span>c2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>뭐가 좋아진걸까?</p>\n<ul>\n<li>buyCoffee를 직접 재사용해서 여러번 구매가 가능해졌다. (buyCoffees 메소드)</li>\n<li>두 메소드 모두 Payments 인터페이스를 추출해서 Mock 구현을 하지 않아도 되었다.</li>\n<li>Cafe는 Charge의 대금이 어떻게 처리되는지 알 수 없게 되었기 때문에, 결제 연동을 신경쓸 필요가 없다.</li>\n</ul>\n<h3>순수 함수란 구체적으로 무엇인가?</h3>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\">A <span class=\"token keyword\">=></span> B</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>위 표현식이 순수 함수라는 가정을 한다면,</p>\n<ul>\n<li>타입이 A인 모든 값 a를 각각 타입이 B인 하나의 값 b에 연관시키되, b가 오직 a에 의해서만 결정되어야 한다.</li>\n<li>내부 또는 외부 공정의 상태 변경은 f(a)의 결과를 계산하는 데 어떠한 영향도 주지 않는다.</li>\n<li>예를 들어 <code class=\"language-text\">Int =&gt; String</code>함수는 모든 정수를 그에 대응되는 문자열로 반환할 뿐, 그 이외의 일은 전혀 하지 않아야 한다.</li>\n<li>\n<p>또 다른 특성으로는 정수 값을 두 개 받고 정수 값 하나를 반환하는 함수가 있다고 하자.</p>\n<ul>\n<li>주어진 임의의 두 정수에 대해 항상 같은 값을 돌려준다.</li>\n<li>그런 의미에서 String.length 메소드도 순수 함수다. (주어진 임의의 문자열에 대해 항상 같은 길이를 돌려주기만 하고 그 외의 일은 전혀 일어나지 않음)</li>\n</ul>\n</li>\n</ul>\n<p>위와 같은 속성을 <strong><u>참조 투명성</u></strong>이라고 한다.</p>\n<ul>\n<li>만일 어떤 표현식을 그 평가 결과로 바꾸어도 프로그램의 의미가 변하지 않는다면, 그 표현식은 참조에 투명한 것이다.</li>\n<li>2 + 3은 하나의 표현식이고 그에 대한 결과는 5다. 여기서 2 + 3을 5로 바꾸어도 프로그램의 의미는 바뀌지 않는다.</li>\n</ul>\n<blockquote>\n<h5>참조 투명성과 순수성</h5>\n<p>만일 모든 프로그램 p에 대해 표현식 e의 모든 출현(occurrence)을 e의 평가 결과로 치환해도 p의 의미에 아무 영향이 미치지 않는다면, 그 표현식 e는 <strong>참조에 투명하다</strong>(referentially transparent). 만일 ㅍ현식 f(x)가 참조에 투명한 모든 x에 대해 참조에 투명하면, 함수 f는 <strong>순수하다</strong>(pure).</p>\n</blockquote>\n<p>Step1에서 봤던 <code class=\"language-text\">buyCoffee</code> 메소드는 참조 투명할까?</p>\n<ul>\n<li>임의의 p라는 함수가 커피를 받는다고 가정하자.</li>\n<li>\n<p><code class=\"language-text\">p(buyCoffee(aliceCreditCard))</code>가 <code class=\"language-text\">p(new Coffee())</code>와 동일하게 작동해야 한다.</p>\n<ul>\n<li><code class=\"language-text\">new Coffee()</code>는 커피만 전달할 뿐 아무 일도 일어나지 않지만</li>\n<li><code class=\"language-text\">buyCoffee(aliceCreditCard)</code>는 커피를 전달하는 것 뿐만 아니라 신용카드 회사에 연결하여 대금을 청구한다.</li>\n<li>따라서 참조 투명하지 않다.</li>\n</ul>\n</li>\n</ul>\n<p>또 다른 예를 살펴보자.</p>\n<h3>java.lang.StringBuilder는 참조 투명하지 않다.</h3>\n<p>왜 그럴까? 다음 예제 코드를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\">scala<span class=\"token operator\">></span> <span class=\"token keyword\">val</span> x <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> StringBuilder<span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span>\nx<span class=\"token operator\">:</span> StringBuilder <span class=\"token operator\">=</span> Hello\n\nscala<span class=\"token operator\">></span> <span class=\"token keyword\">val</span> y <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token string\">\", world\"</span><span class=\"token punctuation\">)</span>\ny<span class=\"token operator\">:</span> StringBuilder <span class=\"token operator\">=</span> Hello<span class=\"token punctuation\">,</span> world\n\n<span class=\"token keyword\">val</span> r1 <span class=\"token operator\">=</span> y<span class=\"token punctuation\">.</span>toString <span class=\"token comment\">// \"Hello, world\"</span>\n<span class=\"token keyword\">val</span> r2 <span class=\"token operator\">=</span> y<span class=\"token punctuation\">.</span>toString <span class=\"token comment\">// \"Hello, world\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>r1과 r2는 같다. 여기서 y의 모든 출현을 append 호출로 치환하면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">scala&gt; val x = new StringBuilder(&quot;Hello&quot;)\nx: StringBuilder = Hello\n\nscala&gt; val y = x.append(&quot;, world&quot;)\ny: StringBuilder = Hello, world\n\nval r1 = x.append(&quot;, world&quot;).toString\nval r2 = x.append(&quot;, world&quot;).toString</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>r1과 r2의 결과는 같지 않다. (r1은 “Hello, world” r2는 “Hello, world, world”)</p>\n<h2>Chapter 02. 스칼라로 함수형 프로그래밍 시작하기</h2>\n<p>이번 챕터에서 다루는 내용</p>\n<ul>\n<li>스칼라 언어의 몇 가지 기본 요소</li>\n<li><strong>꼬리 재귀 함수</strong>를 이용한 루프 작성법</li>\n<li><strong>고차 함수</strong> (다른 함수를 인수로 받는 함수, 결과로 또 다른 함수를 돌려줄 수도 있다.)</li>\n<li><strong>다형적 고차함수</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> MyModule <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> abs<span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> \n    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span>n\n    \t<span class=\"token keyword\">else</span> n\n    \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> formatAbs<span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> msg <span class=\"token operator\">=</span> <span class=\"token string\">\"The absolute value of %d is %d\"</span>\n        msg<span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> abs<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> \n    \tprintln<span class=\"token punctuation\">(</span>formatAbs<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<h5>object 키워드</h5>\n<p>object 키워드는 새로운 싱글톤 객체를 만든다.</p>\n<p>스칼라에는 Java의 static 키워드에 해당하는 것이 없으며, Java에서 정적 멤버를 가진 클래스를 사용할 만한 상황일 때 Scala에서는 object를 사용한다.</p>\n</blockquote>\n<h4>예제코드를 통해 살펴본 스칼라의 기본 개념</h4>\n<ul>\n<li>위의 예제 코드에서 abs와 formatAbs는 순수 함수이다.</li>\n<li>main 메소드는 순수 함수를 호출하고 그 결과를 콘솔에 출력하는 일을 한다. 부수 효과가 발생함을 강조하기 위해 이런 메소드를 절차(Procedure) 또는 <strong>불순 함수</strong>(impure function)라고 부르기도 한다.</li>\n<li>일반적으로, 반환 형식이 Unit이라는 것은 그 메서드에 부수 효과가 존재함을 암시한다.</li>\n<li>MyModule 객체와 같이 자신의 멤버들에게 이름 공간을 제공하는 것이 주된 목적인 객체를 흔히 <strong>모듈</strong>(module)이라고 부른다.</li>\n<li>스칼라에는 연산자(operator)라는 특별한 개념이 존재하지 않으며, 모든 행동은 메소드이다.</li>\n</ul>\n<h4>고차 함수</h4>\n<p>고차 함수(higher-order function, HOF; 또는 고계 함수)를 이해하기 위해, 계승을 구하는 factorial 함수를 작성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> factorial<span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> go<span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">,</span> acc<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> \n    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> acc\n    \t<span class=\"token keyword\">else</span> go<span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">*</span>acc<span class=\"token punctuation\">)</span>\n    \n    go<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>factorial 함수의 본문 안에 재귀적인 보조 함수를 하나 정의함 (go)</li>\n<li>이런 루프용 보조 함수에는 go나 loop 같은 이름을 붙이는 것이 관례</li>\n<li>factorial 함수의 본문은 루프 초기 조건에 해당하는 값으로 go를 호출하는것 뿐이다.</li>\n<li>go 함수는 factorial 함수 안에서만 호출이 가능함</li>\n</ul>\n<p>위 코드는 스칼라에서 꼬리 재귀 호출로 컴파일한다. 왜?</p>\n<ul>\n<li>go의 인수는 남아 있는 값 n과 현재 누적된 계승 acc 다음 반복으로 넘어갈 때는 go 자신을 호출한다.</li>\n<li>\n<p>루프에서 벗어날 때 (n &#x3C;= 0)는 재귀 호출 없이 값을 돌려준다.</p>\n<ul>\n<li>이러한 특성 때문에 재귀 호출이 꼬리 위치(tail position)에서 일어난다면 while 루프를 사용했을 때와 동일한 바이트코드로 컴파일한다. (스택을 소비하지 않는 루프 형태로 컴파일)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h5>스칼라의 꼬리 호출</h5>\n<p>호출자가 재귀 호출의 결과를 그대로 돌려주는 것 외에는 아무 일도 하지 않을 때, 그런 호출을 꼬리 호출이라고 말한다.</p>\n<ul>\n<li>예를 들어 go(n-1, n*acc)는 꼬리 위치에서 일어난다.)</li>\n</ul>\n<p>반면 1 + go(n -1, n*acc) 같은 재귀 호출은 꼬리 호출이 아니다.</p>\n<ul>\n<li>go의 결과에 대해 다른 일(1을 더하는 것)을 수행해야 하기 때문</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">object</span> MyModule <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> abs<span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> \n    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span>n\n    \t<span class=\"token keyword\">else</span> n\n    \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> formatAbs<span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> msg <span class=\"token operator\">=</span> <span class=\"token string\">\"The absolute value of %d is %d\"</span>\n        msg<span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> abs<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> formatFactorial<span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> msg <span class=\"token operator\">=</span> <span class=\"token string\">\"The factorial of %d is %d.\"</span>\n        msg<span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> factorial<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">def</span> main<span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    \tprintln<span class=\"token punctuation\">(</span>formatAbs<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        println<span class=\"token punctuation\">(</span>formatFactorial<span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>formatAbs와 formatFactorial을 하나의 함수 formatResult로 일반화 하면 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> formatResult<span class=\"token punctuation\">(</span>name<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">,</span> f<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token keyword\">=></span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> msg <span class=\"token operator\">=</span> <span class=\"token string\">\"The %s of %d is %d.\"</span>\n    msg<span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\">formatResult<span class=\"token punctuation\">(</span><span class=\"token string\">\"absolute value\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span> abs<span class=\"token punctuation\">)</span>\nformatResult<span class=\"token punctuation\">(</span><span class=\"token string\">\"factorial\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> factorial<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p><u>여기서 formatResult는 f라는 다른 함수를 받는 일종의 고차 함수이다.</u></p>\n<ul>\n<li>고차 함수의 인수에는 f, g, n 같은 이름을 사용하는 것이 관례.</li>\n<li>FP에서는 아주 짧은 변수 이름을 사용하는 경향이 있다.</li>\n<li>왜냐면 인수로 받은 함수가 실제로 수행하는 일에 대해 구체적으로 알지 못하기 때문이다. (고차함수는 그냥 인수의 형식만 알 뿐)</li>\n</ul>\n<h3>다형적 함수</h3>\n<p>다형적 함수(polymorphic function)을 이해하기 위해, 예제를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> findFirst<span class=\"token punctuation\">(</span>ss<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span><span class=\"token builtin\">String</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> key<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@annotation</span><span class=\"token punctuation\">.</span>tailrec\n    <span class=\"token keyword\">def</span> loop<span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> \n    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">>=</span> ss<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n    \t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ss<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key<span class=\"token punctuation\">)</span> n\n    \t<span class=\"token keyword\">else</span> loop<span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    \n    loop<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 배열의 첫 요소에서 루프를 시작한다.</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>여기서는 String 배열로 한정되었지만, Int나 혹은 사용자가 정의한 타입의 배열에서 찾을 수 있게 일반화해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"scala\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-scala line-numbers\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> findFirst<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>as<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> p<span class=\"token operator\">:</span> A <span class=\"token keyword\">=></span> <span class=\"token builtin\">Boolean</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@annotation</span><span class=\"token punctuation\">.</span>tailrec\n    <span class=\"token keyword\">def</span> loop<span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Int</span> <span class=\"token operator\">=</span> \n    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">>=</span> as<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n    \t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">(</span>as<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> n <span class=\"token comment\">// 함수 p가 현재 요소와 부합한다면 원하는 요소를 찾은 것.</span>\n    \t<span class=\"token keyword\">else</span> loop<span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    \n    loop<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<ul>\n<li>파라미터 매개변수의 이름으로는 보통 [A, B, C] 같은 짧은 한 글자짜리 대문자를 사용하는게 관례</li>\n<li>\n<p>findFirst 함수 호출은 다음과 같이 한다.</p>\n<ul>\n<li><code class=\"language-text\">findFirst(Array(7, 9, 13), (x: Int) =&gt; x == 9)</code></li>\n<li>여기서 Array(7, 9, 13)을 <strong>배열 리터럴</strong>이라 한다.</li>\n<li>(x: Int) => x == 9는 <strong>함수 리터럴</strong> 혹은 <strong>익명 함수</strong>라 한다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"스칼라 스터디 Day01 - 함수형 프로그래밍이란?","date":"2018-11-25 02:20:10","tags":["scala","functional programming"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/20181125-scala-and-functional-programming-day01/","previous":{"fields":{"slug":"/20180706-about-grpc/"},"frontmatter":{"title":"gRPC 살펴보기 (gRPC Overview)"}},"next":{"fields":{"slug":"/20181204-scala-and-functional-programming-day02/"},"frontmatter":{"title":"스칼라 스터디 Day02 - 함수적 자료구조"}}}}